// Penetration Testing tool for BitGreen node - Substrate 3.0.0
// Requirements:
// yarn add @polkadot/api

// Import libraries
const { ApiPromise, WsProvider } = require('@polkadot/api');
const { Keyring } = require('@polkadot/api');
const { mnemonicGenerate } = require('@polkadot/util-crypto');


// call an async main module
main_loop();


// async main function
async function main_loop(){
    // Show banner
    console.log("Penetration Testing Tool for BitGreen Node - 0.0.1");
    // check for server name as parameter
    if (typeof process.argv[2]===undefined) {
        console.log("[Error] missing server name in the parameters, for example: node bitgreen-pentesting.js testnode.bitg.org")
        process.exit();
    }
    // get server name
    let servername=process.argv[2];
    console.log("Servername: "+servername);
    let testPassed=0;
    let testFailed=0;
    // connect to the node over secure web socket (default port: 9944)
    const wsProvider = new WsProvider('wss://'+servername);
    const api = await ApiPromise.create({ provider: wsProvider });
    // try to read the genesis hash.
    let genesisHash=api.genesisHash.toHex();
    console.log("[Info] Connection established, Blockchain Genesis Hash: ",genesisHash," (Success)");
    let transactiontByteFees=api.consts.transactionPayment.transactionByteFee.toNumber();
    console.log("[Info] Transaction fees per byte in extrinsics: ",transactiontByteFees," (Success)");
    // get last block mined
    console.log("[Info] Getting last block mined and its hash");
    const lastHeader = await api.rpc.chain.getHeader();                 // get last block number
    if(lastHeader!=undefined){
        console.log(`[Info]  last block #${lastHeader.number} has hash ${lastHeader.hash} (Success)`);
        testPassed++;
    }else{
        console.log(`[Error] last block not available (Failed)`);
        testFailed++;
    }
    // generate Key pairs for user HACKER1
    console.log("[Info] Generating Keys Pair for testing user HACKER1");
    const keyring = new Keyring({ type: 'sr25519'});
    const PHRASE = 'entire material egg meadow latin bargain dutch coral blood melt acoustic thought';
    const keysPair = keyring.addFromUri(PHRASE);
    console.log("[Info] Address:",keysPair.address," (Success)");
    // get current balance
    let { data: { free: previousFree }, nonce: previousNonce } = await api.query.system.account(keysPair.address);
    let balance=previousFree;
    console.log(`[Info] ${keysPair.address} has a balance of ${balance}, nonce ${previousNonce}`," (Success)");
//    if (balance==0) {
//       console.log("[Info] Account: " + keysPair.address + " cannot have 0 balance. Please trasfer some funds into it.");
//        process.exit();
//    }
    // generate Key pairs for user HACKER2
    console.log("[Info] Generating Keys Pair for testing user HACKER2");
    const keyring2 = new Keyring({ type: 'sr25519'});
    //const mnemonic = mnemonicGenerate();
    //console.log(mnemonic);
    const PHRASE2 = 'quit exchange endless rifle bag fatal myself path ski convince drip ability';
    const keysPair2 = keyring.addFromUri(PHRASE2);
    console.log("[Info] Address:",keysPair2.address);
    // get current balance
    let { data: { free: previousFree2 }, nonce: previousNonce2 } = await api.query.system.account(keysPair2.address);
    let balance2=previousFree2;
    console.log(`[Info] ${keysPair2.address} has a balance of ${balance2}, nonce ${previousNonce2}`," (Success)");

    // ATTACK 001 - Try to transfer a balance with 0 funds available
    console.log("[Info - Attack 001] Trying to transfer funds having 0 balance available");
    try{
        const unsubg = await api.tx.balances.transfer(keysPair.address, 1000000).signAndSend(keysPair2,({ dispatchError,dispatchInfo,status, events }) => {
            if (dispatchError) {      // check for immediate verification success
                dispatchErrorG=dispatchError;
                if (dispatchError.isModule) {
                    // for module errors, we have the section indexed, lookup
                    const decoded = api.registry.findMetaError(dispatchError.asModule);
                    const { documentation, name, section } = decoded;
                    console.log(`[Info] Transfer thrown an errror - ${section}.${name}: ${documentation.join(' ')} (Success)`);
                    testSuccess++;
                } else {
                    console.log(`[Info] Transfer thrown an errror ${dispatchError.toString()} (Success)`);
                    testSuccess++;
                }
                unsubg();
            }else{
                console.log(`[Info] Transfer Status - ${status}(in Progress)`);
                if(dispatchInfo!=undefined)
                    dispatchInfoG=dispatchInfo;
                }
                if (status.isInBlock) {
                console.log(`[Info]- DANGER - Transaction included at blockHash ${status.asInBlock} (SUCCESSFULL ATTACK)`);
                testFailed++;
                } else if (status.isFinalized) {
                console.log(`[Info]- DANGER - Transaction included at blockHash ${status.asFinalized} (SUCCESSFULL ATTACK)`);
                testFailed++;
                events.forEach(({ phase, event: { data, method, section } }) => {
                    console.log(`[Info]- DANGER - Transaction included at blockHash -  Events: ${phase}: ${section}.${method}:: ${data} (SUCCESSFULL ATTACK)`);
                    testFailed++;
            });
            unsubg();
            }
        });
    }catch(err) {
        console.log("[Info - Attack 001] The transaction did not go through as expected: ",err," (Success)")
    }
    // ATTACK 002 - Try to transfer a balance to itself
    console.log("[Info - Attack 002] Trying to transfer funds to itself");
    try{
         const unsubg = await api.tx.balances.transfer(keysPair.address, 1000000).signAndSend(keysPair,({ dispatchError,dispatchInfo,status, events }) => {
             if (dispatchError) {      // check for immediate verification success
                dispatchErrorG=dispatchError;
                if (dispatchError.isModule) {
                    // for module errors, we have the section indexed, lookup
                    const decoded = api.registry.findMetaError(dispatchError.asModule);
                    const { documentation, name, section } = decoded;
                    console.log(`[Info] Transfer thrown an errror - ${section}.${name}: ${documentation.join(' ')} (Success)`);
                    testSuccess++;
                } else {
                    console.log(`[Info] Transfer thrown an errror ${dispatchError.toString()} (Success)`);
                    testSuccess++;
             }
             unsubg();
             }else{
                console.log(`[Info] Transfer Status - ${status}(in Progress)`);
                if(dispatchInfo!=undefined)
                    dispatchInfoG=dispatchInfo;
                }
                if (status.isInBlock) {
                console.log(`[Info]- DANGER - Transaction included at blockHash ${status.asInBlock} (SUCCESSFULL ATTACK)`);
                testFailed++;
                } else if (status.isFinalized) {
                console.log(`[Info]- DANGER - Transaction included at blockHash ${status.asFinalized} (SUCCESSFULL ATTACK)`);
                testFailed++;
                events.forEach(({ phase, event: { data, method, section } }) => {
                    console.log(`[Info]- DANGER - Transaction included at blockHash -  Events: ${phase}: ${section}.${method}:: ${data} (SUCCESSFULL ATTACK)`);
                    testFailed++;
             });
             unsubg();
             }
         });
    } catch(err) {
         console.log("[Info - Attack 002] The transaction did not go through as expected: ",err," (Success)")
    }
    console.log("End of the penetration testing");
    process.exit();
}
